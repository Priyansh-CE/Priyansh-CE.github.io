<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Neon Worm Arena</title>
<style>
body{
margin:0;
overflow:hidden;
background:#0a0f1f;
font-family:Arial;
}
#scoreUI{
position:fixed;
top:15px;
left:50%;
transform:translateX(-50%);
color:white;
font-size:20px;
font-weight:bold;
}
</style>
</head>
<body>

<canvas id="game"></canvas>
<div id="scoreUI">Score: 0</div>

<script>
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");
canvas.width=window.innerWidth;
canvas.height=window.innerHeight;

let mouse={x:0,y:0};
let boosting=false;
let score=0;

let camera={x:0,y:0,zoom:1};

class Worm{
constructor(x,y,color){
this.x=x;
this.y=y;
this.segments=[];
this.segmentSize=16;
this.length=30;
this.speed=120;
this.color=color;
this.angle=0;

for(let i=0;i<this.length;i++){
this.segments.push({x,y});
}
}

update(dt){
let dx=mouse.x-canvas.width/2;
let dy=mouse.y-canvas.height/2;
let targetAngle=Math.atan2(dy,dx);

this.angle+= (targetAngle-this.angle)*0.08;

let currentSpeed=this.speed;
if(boosting) currentSpeed*=1.8;

this.x+=Math.cos(this.angle)*currentSpeed*dt;
this.y+=Math.sin(this.angle)*currentSpeed*dt;

this.segments.unshift({x:this.x,y:this.y});
while(this.segments.length>this.length){
this.segments.pop();
}
}

draw(){
for(let i=this.segments.length-1;i>=0;i--){
let seg=this.segments[i];

let gradient=ctx.createRadialGradient(
seg.x,seg.y,2,
seg.x,seg.y,this.segmentSize
);

gradient.addColorStop(0,"white");
gradient.addColorStop(1,this.color);

ctx.fillStyle=gradient;
ctx.beginPath();
ctx.arc(seg.x,seg.y,this.segmentSize,0,Math.PI*2);
ctx.fill();
}

this.drawEyes();
}

drawEyes(){
let head=this.segments[0];
let eyeOffset=6;

ctx.fillStyle="white";
ctx.beginPath();
ctx.arc(head.x+Math.cos(this.angle+0.4)*eyeOffset,
head.y+Math.sin(this.angle+0.4)*eyeOffset,5,0,Math.PI*2);
ctx.fill();

ctx.beginPath();
ctx.arc(head.x+Math.cos(this.angle-0.4)*eyeOffset,
head.y+Math.sin(this.angle-0.4)*eyeOffset,5,0,Math.PI*2);
ctx.fill();

ctx.fillStyle="black";
ctx.beginPath();
ctx.arc(head.x+Math.cos(this.angle+0.4)*eyeOffset,
head.y+Math.sin(this.angle+0.4)*eyeOffset,2,0,Math.PI*2);
ctx.fill();

ctx.beginPath();
ctx.arc(head.x+Math.cos(this.angle-0.4)*eyeOffset,
head.y+Math.sin(this.angle-0.4)*eyeOffset,2,0,Math.PI*2);
ctx.fill();
}
}

class Food{
constructor(){
this.x=(Math.random()-0.5)*3000;
this.y=(Math.random()-0.5)*3000;
this.size=8;
this.hue=Math.random()*360;
this.pulse=0;
}

update(){
this.pulse+=0.05;
}

draw(){
let radius=this.size+Math.sin(this.pulse)*2;

ctx.shadowBlur=15;
ctx.shadowColor=`hsl(${this.hue},100%,60%)`;
ctx.fillStyle=`hsl(${this.hue},100%,50%)`;

ctx.beginPath();
ctx.arc(this.x,this.y,radius,0,Math.PI*2);
ctx.fill();

ctx.shadowBlur=0;
}
}

let worm=new Worm(0,0,"#00f0ff");
let foods=[];
for(let i=0;i<200;i++){
foods.push(new Food());
}

function updateCamera(){
camera.x+=(worm.x-camera.x)*0.08;
camera.y+=(worm.y-camera.y)*0.08;
camera.zoom=1/(1+worm.length*0.01);
}

function checkFood(){
foods.forEach((f,i)=>{
let dx=worm.x-f.x;
let dy=worm.y-f.y;
if(Math.sqrt(dx*dx+dy*dy)<worm.segmentSize){
worm.length+=2;
score+=10;
document.getElementById("scoreUI").innerText="Score: "+score;
foods.splice(i,1);
foods.push(new Food());
}
});
}

let last=0;
function loop(t){
let dt=(t-last)/1000;
last=t;

ctx.clearRect(0,0,canvas.width,canvas.height);

updateCamera();

ctx.save();
ctx.translate(canvas.width/2,canvas.height/2);
ctx.scale(camera.zoom,camera.zoom);
ctx.translate(-camera.x,-camera.y);

foods.forEach(f=>{
f.update();
f.draw();
});

worm.update(dt);
checkFood();
worm.draw();

ctx.restore();

requestAnimationFrame(loop);
}

canvas.addEventListener("mousemove",e=>{
mouse.x=e.clientX;
mouse.y=e.clientY;
});

canvas.addEventListener("mousedown",()=>boosting=true);
canvas.addEventListener("mouseup",()=>boosting=false);

requestAnimationFrame(loop);
</script>
</body>
</html>
