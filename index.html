<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Snake Arena Pro</title>
<style>
body{
    margin:0;
    overflow:hidden;
    background:#0b1220;
}
canvas{display:block;}
#menu{
    position:fixed;
    top:50%;
    left:50%;
    transform:translate(-50%,-50%);
    display:none;
    text-align:center;
}
button{
    padding:12px 25px;
    font-size:18px;
    border:none;
    border-radius:8px;
    cursor:pointer;
    background:#22c55e;
    color:white;
}
</style>
</head>
<body>

<canvas id="game"></canvas>

<div id="menu">
<h2 style="color:white">GAME OVER</h2>
<button onclick="init()">Restart</button>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const WORLD_SIZE = 3000;

let camera = {x:0,y:0};
let player;
let enemies=[];
let foods=[];
let particles=[];
let gameOver=false;
let boosting=false;

class Snake{
    constructor(x,y,color,isAI=false){
        this.points=[];
        this.angle=0;
        this.targetAngle=0;
        this.baseSpeed=2;
        this.length=300;
        this.radius=10;
        this.color=color;
        this.isAI=isAI;

        for(let i=0;i<200;i++){
            this.points.push({x:x-i,y:y});
        }
    }

    update(){
        // Smooth turning
        let diff = this.targetAngle - this.angle;
        diff = Math.atan2(Math.sin(diff), Math.cos(diff));
        this.angle += diff * 0.1;

        if(this.isAI){
            let target = foods[Math.floor(Math.random()*foods.length)];
            if(target){
                this.targetAngle = Math.atan2(
                    target.y-this.points[0].y,
                    target.x-this.points[0].x
                );
            }
        }

        let speed = boosting && !this.isAI ? 4 : this.baseSpeed;

        const head = this.points[0];
        const nx = head.x + Math.cos(this.angle)*speed;
        const ny = head.y + Math.sin(this.angle)*speed;

        this.points.unshift({x:nx,y:ny});

        let total=0;
        for(let i=0;i<this.points.length-1;i++){
            let dx=this.points[i].x-this.points[i+1].x;
            let dy=this.points[i].y-this.points[i+1].y;
            total+=Math.hypot(dx,dy);
            if(total>this.length){
                this.points.splice(i+1);
                break;
            }
        }

        if(boosting && this.length>150 && !this.isAI){
            this.length-=0.5;
        }
    }

    grow(n){ this.length+=n; }

    draw(){
        ctx.lineCap="round";
        ctx.lineJoin="round";
        ctx.lineWidth=this.radius*2;

        ctx.strokeStyle=this.color;
        ctx.shadowColor=this.color;
        ctx.shadowBlur=20;

        ctx.beginPath();
        ctx.moveTo(this.points[0].x,this.points[0].y);
        for(let i=1;i<this.points.length;i++){
            ctx.lineTo(this.points[i].x,this.points[i].y);
        }
        ctx.stroke();
        ctx.shadowBlur=0;
    }
}

function spawnFood(x,y){
    foods.push({
        x:x || Math.random()*WORLD_SIZE,
        y:y || Math.random()*WORLD_SIZE
    });
}

function explodeSnake(snake){
    snake.points.forEach(p=>{
        spawnFood(p.x,p.y);
        for(let i=0;i<2;i++){
            particles.push({
                x:p.x,
                y:p.y,
                dx:(Math.random()-0.5)*6,
                dy:(Math.random()-0.5)*6,
                life:40
            });
        }
    });
}

function init(){
    player=new Snake(WORLD_SIZE/2,WORLD_SIZE/2,"#4ade80");
    enemies=[];
    foods=[];
    particles=[];
    for(let i=0;i<200;i++) spawnFood();

    for(let i=0;i<5;i++){
        enemies.push(new Snake(
            Math.random()*WORLD_SIZE,
            Math.random()*WORLD_SIZE,
            "#ef4444",
            true
        ));
    }

    gameOver=false;
    document.getElementById("menu").style.display="none";
}

canvas.addEventListener("mousemove",e=>{
    player.targetAngle=Math.atan2(
        e.clientY-canvas.height/2,
        e.clientX-canvas.width/2
    );
});

document.addEventListener("keydown",e=>{
    if(e.key==="Shift") boosting=true;
});
document.addEventListener("keyup",e=>{
    if(e.key==="Shift") boosting=false;
});

function checkCollision(){
    enemies.forEach((enemy,ei)=>{
        enemy.points.forEach(seg=>{
            if(Math.hypot(player.points[0].x-seg.x,
                          player.points[0].y-seg.y)<12){
                explodeSnake(player);
                gameOver=true;
                document.getElementById("menu").style.display="block";
            }
        });

        player.points.forEach(seg=>{
            if(Math.hypot(enemy.points[0].x-seg.x,
                          enemy.points[0].y-seg.y)<12){
                explodeSnake(enemy);
                enemies.splice(ei,1);
            }
        });
    });
}

function update(){
    ctx.fillStyle="#0b1220";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    if(!gameOver){
        player.update();
        enemies.forEach(e=>e.update());

        camera.x = player.points[0].x - canvas.width/2;
        camera.y = player.points[0].y - canvas.height/2;

        ctx.save();
        ctx.translate(-camera.x,-camera.y);

        foods.forEach((f,i)=>{
            ctx.beginPath();
            ctx.arc(f.x,f.y,6,0,Math.PI*2);
            ctx.fillStyle="#fde047";
            ctx.fill();

            if(Math.hypot(player.points[0].x-f.x,
                          player.points[0].y-f.y)<15){
                foods.splice(i,1);
                player.grow(30);
                spawnFood();
            }
        });

        player.draw();
        enemies.forEach(e=>e.draw());

        checkCollision();

        ctx.restore();
    }

    particles.forEach((p,i)=>{
        p.x+=p.dx;
        p.y+=p.dy;
        p.life--;
        ctx.fillStyle="orange";
        ctx.fillRect(p.x-camera.x,p.y-camera.y,3,3);
        if(p.life<=0) particles.splice(i,1);
    });

    requestAnimationFrame(update);
}

init();
update();
</script>

</body>
</html>
